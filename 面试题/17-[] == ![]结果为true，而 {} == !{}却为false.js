// == 相等 先进行隐式类型转换再进行比较 === 全等直接进行比较不转换

// !可将变量转换成boolean类型，null和undefined、NaN、以及''空字符串取反都为true,其余都为false
// 隐式转换规则：
// ①、如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
// ②、如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值
// ③、如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较

// 这两个操作符在进行比较时则要遵循下列规则。
// ①、null 和undefined 是相等的
// ②、要比较相等性之前，不能将null 和 undefined 转换成其他任何值
// ③、NaN不和任何值相等，包括自身，只要有和NaN 比较的结果都是false, 注意 NaN !== 任意值 返回是true 变相解释第一句话。
// ④、如果两个操作数都是对象，则比较它们是不是同一个对象，如果两个操作数都指向同一个对象，则相等操作符返回 true；否则， 返回false
 
//  [] == ![] 
// 1. 感叹号！的优先级最高，因此先计算![], 其结果为 false, 所以表达式被转换成： []==false.
// 3. 遇到Boolean类型，需要先转换成Number类型,所以表达是变成 []==0
// 4. 0是基础类型，[]是引用类型，所以引用类型需要转换成基础类型：[]转换的结果是 ([]).valueOf().toString(),为 “”， 所以表达式为  ""==0
// 5. 字符串需要转换成Number，为0. 所以表达式变成 0==0.
// 6. 最后结果为true.

// {}==!{}
// 1. 感叹号！的优先级最高，因此先计算!{}, 其结果为 false, 所以表达式被转换成： {}==false.
// 3. 遇到Boolean类型，需要先转换成Number类型,所以表达是变成 []==0
// 4. 0是基础类型，{}是引用类型，所以引用类型需要转换成基础类型：{}转换的结果是 ({}).valueOf().toString(),为 “[object Object]”， 所以表达式为  "[object Object]"==0
// 5. 字符串需要转换成Number，为NaN. 所以表达式变成 NaN==0.
// 6. 最后结果为false. 

// 搞懂toString()与valueOf()的区别
// 1. toString() 返回一个表示该对象的字符串，"[object type]",其中type是对象类型。
// 2. valueOf()  用来把对象转换成原始类型的值（数值、字符串和布尔值） 
// 3. 在进行强转字符串类型时将优先调用toString方法，强转为数字时优先调用valueOf